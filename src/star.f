c     Subroutine to initialize the star-fitting routines. This
c     subroutine will initialize the bands and the templates.
c
        subroutine starinit(filtname,inum,verb_flag)
        implicit real*8 (a-h,o-z)
        parameter (NCMAX=32,NWMAX=350,NSMAX=4,NTMAX=4)

        character filtname*(*)

        integer verbose,verb_flag
        common /verb/verbose

        integer pzon
        common /regen/zmax2,zmin2,dz2,pzon

        verbose = verb_flag

c     Initialize the filters.
        call setfilt(filtname)
c     Read the zero point normalizations or otherwise initialize them
        call read_zpc
c     Initialize the templates.
        call settemp_star(inum)

        return
        end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c     The KCA function calculates K corrections based on the templates
c     generated by Assef & Kochanek et al. 2007 (in preparation). 
c     The arguments are:
c
c
c     num     = number of bands on which the photometry is being
c               supplied (integer)
c     
c     mag     = vector of n components containing the observed 
c               magnitudes (real*8)
c     
c     emag    = vector of n components containing the errors in the 
c               magnitudes (real*8)
c     
c     maguse  = vector of n components containing which magnitudes will
c               be used to fit the galaxy to the templates. 1 means to
c               be used and 0 to not be used.  For bands not used in
c               the fit, a kcorrection will also be calculated as well
c               as a model flux. (integer)
c     
c     zobj    = redshift of the galaxy (real*8)
c
c     z0      = redshift to which you want to k correct (real*8)
c     
c     magmod  = vector of n components on which the modeled magnitudes
c               will be returned (real*8)
c     
c     magcorr = vector of n components on which the kcorrections in
c               magnitudes are returned (real*8)
c
c     comp    = vector with at least dimensions equal to the number
c               of templates used (real*8)
c     
c     op      = 1 if mag is in magnitudes and 0 if it is in flux. 
c     
c     
c     Note that the following functions do not necessarily follow the 80
c     character per line fortran 77 convention. Compilation with g77 has
c     to include the -ffixed-line-length-none flag. Compilation with
c     intel fortran compiler, ifort, has to include the -extend_source
c     flag. Also note that min.f should be compiled simultaneously.
c     
c     This function should only be called after calling setfilt and
c     settemp.
c
        subroutine star_fit(mag,emag,maguse,magmod,comp,chi2,op)
        implicit real*8(a-h,o-z)
        parameter (NCMAX=32,NWMAX=350,NSMAX=4,NTMAX=4)

        real*8 mag(*),emag(*),magmod(*),magcorr(*),comp(*)
        real*8 covx(NSMAX,NSMAX)
        integer maguse(*),op

        real*8 z
        real*8 jy(NCMAX),ejy(NCMAX)
        integer nchan
        common /data1b/jy,ejy,nchan
        common /data1/z

        integer jyuse(NCMAX)
        common /data2/jyuse

        real*8 vec(NSMAX)
        real*8 jymod(NSMAX,NCMAX)
        real*8 jymodtot(NCMAX)
        common /models/jymod,jymodtot,vec

        real*8 jyzero(NCMAX),con(NCMAX),lbar(NCMAX)
        common /cal1/jyzero,con,lbar

        real*8 bedge(NWMAX)
        real*8 bcen(NWMAX)
        common /wavegrid/bedge,bcen,nwave

        real*8 wgt(NCMAX,NWMAX)
        real*8 c(NCMAX)
        common /weights1/wgt,c
        integer jwmin(NCMAX),jwmax(NCMAX)
        common /weights2/jwmin,jwmax 

        real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
        common /specmod1/spec,specuse,nspec
        common /specnorm/bminnorm,bmaxnorm

        real*8 chimin
        common /minchi/chimin

c   We are fitting stars, so z=0.
        z = 0.d0

c     See which bands will be used for fitting.
        m = 0
        do j = 1,nchan
            if(maguse(j).ne.0.and.maguse(j).ne.1.and.maguse(j).ne.2) then
                write(0,*)'maguse(',j,')=',maguse(j),' not equal to 1 or 0 in function kca.'
                write(0,*)'Aborting program'
                stop
            else
                jyuse(j) = maguse(j)
                if(jyuse(j).ge.1) m = m + 1
            endif
        enddo

c     Since we are fitting two templates at a time, make sure there are at least 2 magnitudes/fluxes.
        nspec_fit = 2
        if(m.lt.nspec_fit) then
            write(0,*)'Too few magnitudes to fit stellar models (<',nspec_fit,').'
            do j=1,nchan
                magmod(j)  = -99.
                magcorr(j) = -99.
            enddo
            do l=1,nspec
                comp(l) = -1
            enddo
            goto 500
        endif

        if(op.eq.1) then
c     If op = 1, transform from magnitudes to fluxes. 
            do jchan = 1,nchan
            if(jyuse(jchan).eq.1) then
                jy(jchan)  = jyzero(jchan)*10.0**(-0.4*mag(jchan))
                ejy(jchan) = 0.4*log(10.0)*emag(jchan)*jy(jchan)
            else if(jyuse(jchan).eq.2) then
                jy(jchan)  = 0.d0
                ejy(jchan) = jyzero(jchan)*10.0**(-0.4*emag(jchan))
            else
                jy(jchan)  = 0.d0
                ejy(jchan) = 0.d0
            endif
            ejy(jchan) = ejy(jchan)**2
            enddo
        else if(op.eq.0) then
c     If op = 0, data is in flux.
            do jchan = 1,nchan
                jy(jchan)  = mag(jchan)
                if(jyuse(jchan).eq.2) jy(jchan) = 0.d0
                ejy(jchan) = emag(jchan)**2
            enddo
        else
            write(0,*)'Not a valid value for op in function kca.'
            write(0,*)'Input 0 if data is in Jy and 1 if data is in magnitudes'
            stop
        endif

c     Build the weights
        do jchan=1,nchan
            do kwave=1,nwave
                wgt(jchan,kwave) = getweight(z,jchan,kwave)
            enddo
            call getrange(jchan)         
        enddo

c     Now Fit the Model Fluxes to the spectra. Allow for fixed
c     components with a provided amplitude.
        do l = 1,nspec
            vec(l) = 0.d0
        enddo
        call run_stellar_fit

        do j=1,nchan
            jymodtot(j)   = 0.d0
            do l = 1,nspec
                jymodtot(j)   = jymodtot(j) + vec(l)*jymod(l,j)
            enddo
        enddo


        if(op.eq.1) then
c     Write the results in magnitudes if op==1.
            do j = 1,nchan
                magmod(j)  = -2.5*log10(jymodtot(j)/jyzero(j))
            enddo
        else if(op.eq.0) then
            do j = 1,nchan
                magmod(j)  = jymodtot(j)
            enddo
        endif


c     Copy the components of vector vec to the output comp and scale
c     them to specific luminosities units. Assume a distance of 10pc.
        vecfac = (10.d-6)**2*1d10*3d-9
        do l = 1,nspec
            comp(l) = vec(l)*vecfac/alpha_norm(l)         
        enddo

500     continue

        return
        end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c     Determine the fit coefficients for individual galaxies.
        subroutine kca_fitgal
        implicit real*8 (a-h,o-z)
        parameter (NCMAX=32,NGMAX=17000,NWMAX=350,NSMAX=4,NTMAX=4)
        
        real*8 z
        real*8 jy(NCMAX),ejy(NCMAX)
        integer nchan
        common /data1b/jy,ejy,nchan
        common /data1/z      

        integer jyuse(NCMAX)
        common /data2/jyuse
        
        real*8 vec(NSMAX)
        real*8 jymod(NSMAX,NCMAX)
        real*8 jymodtot(NCMAX)
        common /models/jymod,jymodtot,vec
        
        real*8 spec(NSMAX,NWMAX),specuse(NSMAX,NWMAX)
        common /specmod1/spec,specuse,nspec
        common /specnorm/bminnorm,bmaxnorm
        
        real*8 wgt(NCMAX,NWMAX)
        real*8 c(NCMAX)
        common /weights1/wgt,c
        integer jwmin(NCMAX),jwmax(NCMAX)
        common /weights2/jwmin,jwmax
        
        real*8 bedge(NWMAX)
        real*8 bcen(NWMAX)
        common /wavegrid/bedge,bcen,nwave
        
        real*8 a(10,10),b(10)
        real*8 atemp(10,10),btemp(10)
        real*8 asave(10,10),bsave(10)
        real*8 tempw(10),tempv(10,10),tempz(10)
        integer itempv(10)
        real*8 temps(10),temps2(10)

        real*8 jymodx(NSMAX,NCMAX)
        common /modelsx/jymodx

        real*8 vecbest(NSMAX)
        real*8 jymodbest(NSMAX,NCMAX)
        real*8 jymodtotbest(NCMAX)

        real*8 cov(NSMAX,NSMAX)
        common /vecerr/cov

        real*8 tigm(NWMAX)

        real*8 chimin
        common /minchi/chimin

        real*8 work(500)
        integer ipiv(10)

        chimin = 1.d32
    

c   Initialize the chi2
        chi = 0.d0


c     Work out the contribution from each template to the object
        do l=1,nspec
            do j=1,nchan
                jymod(l,j) = 0.d0
                do k=jwmin(j),jwmax(j)
                    jymod(l,j) = jymod(l,j) + c(j)*spec(l,k)*wgt(j,k)
                enddo
            enddo
        enddo
            
c     Compute the present model
        maxdim = 10
        call clearmat(atemp,btemp,maxdim,nspec)
        do j=1,nchan
            if (jyuse(j).ge.1) then
                do l1=1,nspec
                    b(l1) = b(l1) + jy(j)*jymod(l1,j)/ejy(j) 
                    do l2=l1,nspec 
                        a(l1,l2) = a(l1,l2) + jymod(l1,j)*jymod(l2,j)/ejy(j) 
                    enddo
                enddo
            endif
        enddo
        call symmat(atemp,btemp,maxdim,nspec)

c     Save the matrices
        do l1=1,nm1
            bsave(l1) = b(l1)
            do l2=1,nm1
                asave(l1,l2) = a(l1,l2)
            enddo
        enddo

c     Solve assuming only positive coefficients. If convergence fails,
c     revert to the slower version going through all possible
c     combinations.
        call my_nnls_2(a,maxdim,nm1,nm1,b,temps,MODE,its,0)
        if(MODE.eq.3) then
            do l1=1,nm1
                b(l1) = bsave(l1)
                do l2=1,nm2
                a(l1,l2) = asave(l1,l2)
                enddo
            enddo
            nm3 = 0
            do l=1,nspec
                if(ivaryobj(l).eq.1) then
                nm3 = nm3 + 1
                do j=1,nchan
                    jymodx(nm3,j) = jymod(l,j)
                enddo
                endif
            enddo
            call ANNLS(a,maxdim,nm1,nm1,b,temps)
        endif

c     Copy solution out into final vector
        nm1  = 0
        do l1=1,nspec
            nm1     = nm1 + 1
            vec(l1) = temps(nm1)
        enddo

c     Calculate the chi-square of the fit.
        do j=1,nchan
            jymodtot(j) = 0.d0
            do l=1,nspec
                jymodtot(j) = jymodtot(j) + vec(l)*jymod(l,j)
            enddo
            if(jyuse(j).ge.1) then
                diff = jy(j)-jymodtot(j)
                chi  = chi + diff*diff/ejy(j)
            endif
        enddo

            if(chi.le.chitabebv(ie)) chitabebv(ie) = chi
            if(chi.le.chitabigm(ig)) chitabigm(ig) = chi
            if(chi.le.chimin) then
                chimin = chi
                ebv    = euse
                igm    = guse
                iebst  = ie
                igbst  = ig
                do l=1,nspec
                    vecbest(l) = vec(l)
                    do j=1,nchan
                    jymodbest(l,j) = jymod(l,j)
                    enddo
                enddo
                do j=1,nchan
                    jymodtotbest(j) = jymodtot(j)
                enddo 
    c     Estimate the template errors.
                nm1 = 0
                do l=1,nspec
                    nm1 = nm1 + ivaryobj(l)
                enddo
                lwork = 500
                call dgetrf(nm1,nm1,asave,maxdim,ipiv,INFO)               
                call dgetri(nm1,asave,maxdim,ipiv,work,lwork,INFO)
                nm1 = 0.d0
                do l1=1,nspec
                    nm2 = 0
                    if(ivaryobj(l1).eq.1) then
                    nm1 = nm1 + 1
                    do l2=1,nspec
                        if(ivaryobj(l2).eq.1) then
                            nm2 = nm2 + 1
                            cov(l1,l2) = asave(nm1,nm2)
                        else
                            cov(l1,l2) = 0.d0
                        endif
                    enddo
                    else
                    do l2=1,nspec
                        cov(l1,l2) = 0.d0
                    enddo
                    endif
                enddo              
            endif 

        enddo
        enddo

    c     Now that we've finished the main cycle, get the best fit
    c     values. Notice that this is not immediate from the last cycle, as
    c     it is possible for the interpolation scheme to give a larger chi2
    c     as the surface is not necessarily a good paraboloid.
        do l=1,nspec
        vec(l) = vecbest(l)
        do j=1,nchan
            jymod(l,j) =jymodbest(l,j)
        enddo
        enddo
        do j=1,nchan
        jymodtot(j) = jymodtotbest(j)
        enddo

    c     Finally remove the prior term from the chi2.
        if(use_red_igm_prior.eq.1) then
        chimin = chimin - ((ebv/0.5d0)**2 + ((igm-1.d0)/0.5d0)**2)
        endif

        return
        end

